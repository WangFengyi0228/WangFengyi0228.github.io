<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangfengyi0228.github.io</id>
    <title>one in a million</title>
    <updated>2021-11-12T04:42:46.735Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangfengyi0228.github.io"/>
    <link rel="self" href="https://wangfengyi0228.github.io/atom.xml"/>
    <subtitle>我在你的心里，有没有一点特别</subtitle>
    <logo>https://wangfengyi0228.github.io/images/avatar.png</logo>
    <icon>https://wangfengyi0228.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, one in a million</rights>
    <entry>
        <title type="html"><![CDATA[Qt | 智能巡检机器人项目]]></title>
        <id>https://wangfengyi0228.github.io/post/qt-or-zhi-neng-xun-jian-ji-qi-ren-xiang-mu/</id>
        <link href="https://wangfengyi0228.github.io/post/qt-or-zhi-neng-xun-jian-ji-qi-ren-xiang-mu/">
        </link>
        <updated>2021-08-28T03:38:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>notes:该机器人使用卫星进行经纬度定位，适用于开阔地带，初始化搜星数达到19以上为佳，距离精度精确到小数点后16位（以米为单位）<br>
<strong>项目总体框图：</strong><br>
<img src="https://wangfengyi0228.github.io/post-images/1636688828688.png" alt="" loading="lazy"><br>
<strong>逻辑流程图：</strong><br>
<img src="https://wangfengyi0228.github.io/post-images/1636691559203.png" alt="" loading="lazy"><br>
<strong>ChasisSender</strong><br>
ChasisSender构造即启动两个串口（Imu串口和Cmd串口），Imu串口负责接收Imu数据和定位数据，将数据解析后发送到LtkjCenter。Cmd串口负责发送控制指令（速度和转角）到底盘控制器，自定义格式为“$cmd,转角,速度\r\n”。Cmd串口数据的发送在接收到LtkjCenter的control_msg信号后，开始发送，接收到control_msg.cmd_stop信号后关闭cmd串口，停止发送。</p>
</blockquote>
<ul>
<li>Signal:Chasis_state_signal(ChasisState) 向LtkjCenter发送底盘状态</li>
<li>Signal:Car_position_signal(Position) 向LtkjCenter发送车辆位置</li>
<li>Slot:ProcessImuMsg_slot() 接收Imu串口消息</li>
</ul>
<pre><code>void ChasisSender::ProcessImuMsg_slot()
{
    if(!imu_serial-&gt;canReadLine())   return ;
    QByteArray readData = imu_serial-&gt;readAll();
    if(readData.isEmpty())  return ;

    if(readData[0] == '$')
    {
        QString ImuData_str = QString(readData);
        QStringList tmpImuData_Lis = ImuData_str.split(&quot;,&quot;);

        if (tmpImuData_Lis.count() == 24)
        {
            QString imuYawangle_str = tmpImuData_Lis[3];
            QString imuLatitude_str = tmpImuData_Lis[12];
            QString imuLongitude_str = tmpImuData_Lis[13];

            Position tmp_position(0, 0, 0);
            tmp_position.x = imuLongitude_str.toDouble();
            tmp_position.y = imuLatitude_str.toDouble();
            tmp_position.theta = imuYawangle_str.toDouble();

            WGS2CART(car_position_,tmp_position);
            car_position_.x -= Origin_position_.x;
            car_position_.y -= Origin_position_.y;

            qDebug() &lt;&lt; &quot;x: &quot; &lt;&lt; car_position_.x &lt;&lt; &quot; y: &quot; &lt;&lt; car_position_.y &lt;&lt; &quot; z: &quot; &lt;&lt; car_position_.theta;

            chasis_state_.imu_state_ = 1;
            emit Chasis_state_signal(chasis_state_); 
            emit Car_position_signal(car_position_);  
       }
    }
    imu_serial-&gt;clear();
}

•Slot:ReceiveCmdMsg_slot(control_msg) 接收LtkjCenter控制指令
void ChasisSender::ReceiveCmdMsg_slot(control_msg msg)  
{
    if(!msg.cmd_stop)
    {
        if(cmd_serial-&gt;isOpen())
        {
            cmd_angle = msg.cmd_angle;
            cmd_speed = msg.cmd_speed;
            SendCmdSerialData();
        }
        else
        {
            OpenCmdSerialport();
        }
    }
    else
    {
        if(cmd_serial-&gt;isOpen())
        {
            CloseCmdSerialport();
        }
    }
}
</code></pre>
<p><strong>UdpReceiver</strong><br>
UdpReceiver构造即启动udp接收，具体绑定的IP和端口需要在构造函数中修改，这里不再提供修改的接口。接收的槽函数已经写好，解析需要根据协议来定，这个留着后期再加。测试阶段只保证实现功能。在udp接收槽接收到消息之后，进行解析，发送任务指令到LtkjCenter。</p>
<ul>
<li>Signal:CommandSingal(task_msg) 向LtkjCenter发送任务命令</li>
<li>Slot:Udp_receiver_slot() 接收udp消息并进行解析</li>
<li>Slot:Udp_position_slot(Position); 接收LtkjCenter车辆位置信息</li>
<li>Slot:Send_Timer_slot() 向LtkjCenter发送心跳</li>
</ul>
<pre><code>void UdpReceiver::Udp_receiver_slot() 
{
    while (udp_receiver_-&gt;hasPendingDatagrams()) 
    {
        QByteArray datagram;
        datagram.resize(udp_receiver_-&gt;pendingDatagramSize( ));
        udp_receiver_-&gt;readDatagram (datagram.data( ), datagram.size());

        if(datagram[0] == '$')
        {
            QString udp_str = QString(datagram);
            QStringList udp_str_list = udp_str.split(&quot;,&quot;);
            if(udp_str_list.count() == 4)
            {
                action = udp_str_list[1].toInt();
                end_pos_.setX(udp_str_list[2].toDouble());
                end_pos_.setY(udp_str_list[3].toDouble());
            }
        }
        // qDebug() &lt;&lt; datagram;
        task_msg_.state = action;
        task_msg_.point_target = end_pos_;
        emit CommandSingal(task_msg_);
    }
}
</code></pre>
<p><strong>LtkjCenter</strong><br>
LtkjCenter包含了LtkjMap和LtkjControl两个类。<br>
逻辑见流程图</p>
<ul>
<li>Signal:Chasis_cmd_signal(control_msg) 向ChasisSender发送控制指令，转角和速度以及停止信号</li>
<li>Slot:Command_slot(QString cmd) 接收UdpReceiver任务消息</li>
</ul>
<pre><code>void LtkjCenter::Command_slot(task_msg cmd)
{
    qDebug() &lt;&lt; &quot;rece from udp: &quot; &lt;&lt; cmd.state &lt;&lt; &quot; and &quot; &lt;&lt; cmd.point_target;
    if(cmd.state == 0)
    {
        if(track_timer-&gt;isActive())
        {
            track_timer-&gt;stop();
        }
        SetReady();
    }
    else if(cmd.state == 1)
    {
        end_position_.x = cmd.point_target.x();
        end_position_.y = cmd.point_target.y();
        end_position_.theta = 0;

        if(map_path_state_.map_state_ == 1 &amp;&amp; chasis_state_.imu_state_ == 1)
        {
            Position2QPointF(car_point, car_position_);
            Position2QPointF(end_point, end_position_);
            map_.AStar(car_point, end_point);           
            UpdateMapState();
        }
        else
        {
            qDebug() &lt;&lt; &quot;Error: map_state = 0 !&quot;;
            SetReady();
            return ;
        }

        if(map_path_state_.path_state_ == 1)
        {
            if(!track_timer-&gt;isActive())
            {
                track_timer-&gt;start(100);
            }
            else
            {
                SetReady();
                track_timer-&gt;start(100);
                qDebug() &lt;&lt; &quot;Warning: New Task Failed, Track task is in Progress&quot;;
            }

        }
        else
        {
            qDebug() &lt;&lt; &quot;Error: map_path = 0!&quot;;
            return ;
        }
    }
}
</code></pre>
<ul>
<li>Slot:Chasis_state_slot(ChasisState) 接收ChasisSender底盘状态消息<pre><code></code></pre>
</li>
</ul>
<p>void LtkjCenter::Chasis_state_slot(ChasisState state)<br>
{<br>
chasis_state_.imu_state_ = state.imu_state_;<br>
}```</p>
<ul>
<li>Slot:Chasis_position_slot(Position) 接收ChasisSender车辆位置消息</li>
</ul>
<pre><code class="language-void">{
    car_position_.x = pos.x;
    car_position_.y = pos.y;
    car_position_.theta = pos.theta;

    emit Position_signal(car_position_);
}```
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Practice | Missing number]]></title>
        <id>https://wangfengyi0228.github.io/post/practice-or-missing-number/</id>
        <link href="https://wangfengyi0228.github.io/post/practice-or-missing-number/">
        </link>
        <updated>2021-04-26T04:40:22.000Z</updated>
        <content type="html"><![CDATA[<p>Given a positive integer n(n≤40), pick n-1 numbers randomly from 1 to n and concatenate them in random order as a string s, which means there is a missing number between 1 and n. Can you find the missing number?(Notice that in some cases the answer will not be unique, and in these cases you only need to find one valid answer.）</p>
<h2 id="sample-input-1">Sample Input 1:</h2>
<p>20<br>
81971112205101569183132414117</p>
<h2 id="sample-output-1">Sample Output 1:</h2>
<p>16</p>
<h1 id="solution">Solution:</h1>
<p>#include &lt;bits/stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>int len,n;<br>
bool f[100];<br>
string s;<br>
int num[100];</p>
<p>void dfs(int k)<br>
{<br>
if(k&gt;=len)<br>
{<br>
for(int i=1;i&lt;=n;i++)<br>
{<br>
if(f[i]==false)<br>
{<br>
printf(&quot;%d\n&quot;,i);<br>
}<br>
}<br>
return;<br>
}<br>
if(f[num[k]]==false)<br>
{<br>
f[num[k]]=true;<br>
dfs(k+1);<br>
f[num[k]]=false;<br>
}<br>
if(f[num[k]*10+num[k+1]]==false&amp;&amp;num[k]*10+num[k+1]&lt;=n)<br>
{<br>
f[num[k]*10+num[k+1]]=true;<br>
dfs(k+2);<br>
f[num[k]*10+num[k+1]]=false;<br>
}<br>
}</p>
<p>int main()<br>
{<br>
scanf(&quot;%d&quot;,&amp;n);<br>
cin&gt;&gt;s;<br>
for(int i=0;i&lt;s.size();i++)<br>
{<br>
num[i]=s[i]-'0';<br>
}<br>
len=s.size();<br>
dfs(0);<br>
return 0;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Practice | Root of AVL Tree]]></title>
        <id>https://wangfengyi0228.github.io/post/practice-or-root-of-avl-tree/</id>
        <link href="https://wangfengyi0228.github.io/post/practice-or-root-of-avl-tree/">
        </link>
        <updated>2019-11-19T04:36:26.000Z</updated>
        <content type="html"><![CDATA[<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.<br>
<img src="https://wangfengyi0228.github.io/post-images/1636692006948.png" alt="" loading="lazy"><br>
Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<h1 id="input-specification">Input Specification:</h1>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h1 id="output-specification">Output Specification:</h1>
<p>For each test case, print the root of the resulting AVL tree in one line.</p>
<h2 id="sample-input-1">Sample Input 1:</h2>
<p>5<br>
88 70 61 96 120</p>
<h2 id="sample-output-1">Sample Output 1:</h2>
<p>70</p>
<h2 id="sample-input-2">Sample Input 2:</h2>
<p>7<br>
88 70 61 96 120 90 65</p>
<h2 id="sample-output-2">Sample Output 2:</h2>
<p>88</p>
<h1 id="solution">Solution:</h1>
<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef struct node
{
    int data,height;
    node *lchild,*rchild;
}node;

int getheight(node* k)
{
    if(k==nullptr)
        return 0;
    else return k-&gt;height;
}

node* l_rotate(node* &amp;k1)
{
    node *k2=k1-&gt;rchild;

    k1-&gt;rchild=k2-&gt;lchild;
    k2-&gt;lchild=k1;
    k1-&gt;height=max(getheight(k1-&gt;lchild),getheight(k1-&gt;rchild))+1;
    k2-&gt;height=max(getheight(k2-&gt;lchild),getheight(k2-&gt;rchild))+1;
    return k2;
}

node* r_rotate(node* &amp;k1)
{
    node *k2=k1-&gt;lchild;

    k1-&gt;lchild=k2-&gt;rchild;
    k2-&gt;rchild=k1;
    k1-&gt;height=max(getheight(k1-&gt;rchild),getheight(k1-&gt;lchild))+1;
    k2-&gt;height=max(getheight(k2-&gt;rchild),getheight(k2-&gt;lchild))+1;
    return k2;
}

node* lr_rotate(node* &amp;k1)
{
    k1-&gt;lchild=l_rotate(k1-&gt;lchild);
    return r_rotate(k1);
}

node* rl_rotate(node* &amp;k1)
{
    k1-&gt;rchild=r_rotate(k1-&gt;rchild);
    return l_rotate(k1);
}

node* insertnode(int d,node* &amp;root)
{
    if(root==nullptr)
    {
        root=(node*)malloc(sizeof(node));
        root-&gt;data=d;
        root-&gt;lchild=nullptr;
        root-&gt;rchild=nullptr;
        root-&gt;height=0;
    }
    else if(d&lt;root-&gt;data)
    {
        root-&gt;lchild=insertnode(d,root-&gt;lchild);
        if(getheight(root-&gt;lchild)-getheight(root-&gt;rchild)==2)
        {
            if(d&lt;root-&gt;lchild-&gt;data)
            {
                root=r_rotate(root);
            }
            else
            {
                root=lr_rotate(root);
            }
        }
    }
    else if(d&gt;root-&gt;data)
    {
        root-&gt;rchild=insertnode(d,root-&gt;rchild);
        if(getheight(root-&gt;rchild)-getheight(root-&gt;lchild)==2)
        {
            if(d&gt;root-&gt;rchild-&gt;data)
            {
                root=l_rotate(root);
            }
            else
            {
                root=rl_rotate(root);
            }
        }
    }
    root-&gt;height=max(getheight(root-&gt;lchild),getheight(root-&gt;rchild))+1;
    return root;
}

int main()
{
    int n;
    cin&gt;&gt;n;
    node *root=nullptr;
    for(int i=0;i&lt;n;i++)
    {
        int tmp;
        scanf(&quot;%d&quot;,&amp;tmp);
        root=insertnode(tmp,root);
    }
    printf(&quot;%d&quot;,root-&gt;data);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome to My World]]></title>
        <id>https://wangfengyi0228.github.io/post/hello-gridea/</id>
        <link href="https://wangfengyi0228.github.io/post/hello-gridea/">
        </link>
        <updated>2000-02-28T14:45:00.000Z</updated>
        <content type="html"><![CDATA[<p>2000-02-28  Student ，  XMU</p>
<p>👏 欢迎来到我的blog ！持续建设ing<br>
✍️ 记录我的笔记、生活、心情... ...<br>
🤙 不要问我为什么图文不符，因为我愿意😋</p>
<p>🎓 想要了解更多或联系博主请查看关于<br>
🕙 想要按时间检索文章请查看归档<br>
📑 想要按tag检索文章请查看标签<br>
🔝右上角有导航栏哦</p>
<p>🌱 当然 wfy 还有很多不足，但请相信我会不停向前 🏃</p>
<p>😎 Enjoy~</p>
<p>2021.9.19 | 更新了标签检索功能<br>
2021.9.21 | 尝试添加评论功能失败，因为disqus被墙了😭，小王还在努力中<br>
2021.9.27 | 新增网站访客统计及访问量统计功能<br>
2021.9.28 | 新增文章阅读量统计功能<br>
2021.10.2 | 新增Katex渲染，可以用markdown写公式啦</p>
]]></content>
    </entry>
</feed>