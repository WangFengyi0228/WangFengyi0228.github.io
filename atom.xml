<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangfengyi0228.github.io</id>
    <title>one in a million</title>
    <updated>2021-11-12T04:46:53.608Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangfengyi0228.github.io"/>
    <link rel="self" href="https://wangfengyi0228.github.io/atom.xml"/>
    <subtitle>æˆ‘åœ¨ä½ çš„å¿ƒé‡Œï¼Œæœ‰æ²¡æœ‰ä¸€ç‚¹ç‰¹åˆ«</subtitle>
    <logo>https://wangfengyi0228.github.io/images/avatar.png</logo>
    <icon>https://wangfengyi0228.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, one in a million</rights>
    <entry>
        <title type="html"><![CDATA[Qt | æ™ºèƒ½å·¡æ£€æœºå™¨äººé¡¹ç›®]]></title>
        <id>https://wangfengyi0228.github.io/post/qt-or-zhi-neng-xun-jian-ji-qi-ren-xiang-mu/</id>
        <link href="https://wangfengyi0228.github.io/post/qt-or-zhi-neng-xun-jian-ji-qi-ren-xiang-mu/">
        </link>
        <updated>2021-08-28T03:38:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>notes:è¯¥æœºå™¨äººä½¿ç”¨å«æ˜Ÿè¿›è¡Œç»çº¬åº¦å®šä½ï¼Œé€‚ç”¨äºå¼€é˜”åœ°å¸¦ï¼Œåˆå§‹åŒ–æœæ˜Ÿæ•°è¾¾åˆ°19ä»¥ä¸Šä¸ºä½³ï¼Œè·ç¦»ç²¾åº¦ç²¾ç¡®åˆ°å°æ•°ç‚¹å16ä½ï¼ˆä»¥ç±³ä¸ºå•ä½ï¼‰<br>
<strong>é¡¹ç›®æ€»ä½“æ¡†å›¾ï¼š</strong><br>
<img src="https://wangfengyi0228.github.io/post-images/1636688828688.png" alt="" loading="lazy"><br>
<strong>é€»è¾‘æµç¨‹å›¾ï¼š</strong><br>
<img src="https://wangfengyi0228.github.io/post-images/1636691559203.png" alt="" loading="lazy"><br>
<strong>ChasisSender</strong><br>
ChasisSenderæ„é€ å³å¯åŠ¨ä¸¤ä¸ªä¸²å£ï¼ˆImuä¸²å£å’ŒCmdä¸²å£ï¼‰ï¼ŒImuä¸²å£è´Ÿè´£æ¥æ”¶Imuæ•°æ®å’Œå®šä½æ•°æ®ï¼Œå°†æ•°æ®è§£æåå‘é€åˆ°LtkjCenterã€‚Cmdä¸²å£è´Ÿè´£å‘é€æ§åˆ¶æŒ‡ä»¤ï¼ˆé€Ÿåº¦å’Œè½¬è§’ï¼‰åˆ°åº•ç›˜æ§åˆ¶å™¨ï¼Œè‡ªå®šä¹‰æ ¼å¼ä¸ºâ€œ$cmd,è½¬è§’,é€Ÿåº¦\r\nâ€ã€‚Cmdä¸²å£æ•°æ®çš„å‘é€åœ¨æ¥æ”¶åˆ°LtkjCenterçš„control_msgä¿¡å·åï¼Œå¼€å§‹å‘é€ï¼Œæ¥æ”¶åˆ°control_msg.cmd_stopä¿¡å·åå…³é—­cmdä¸²å£ï¼Œåœæ­¢å‘é€ã€‚</p>
</blockquote>
<ul>
<li>Signal:Chasis_state_signal(ChasisState) å‘LtkjCenterå‘é€åº•ç›˜çŠ¶æ€</li>
<li>Signal:Car_position_signal(Position) å‘LtkjCenterå‘é€è½¦è¾†ä½ç½®</li>
<li>Slot:ProcessImuMsg_slot() æ¥æ”¶Imuä¸²å£æ¶ˆæ¯</li>
</ul>
<pre><code>void ChasisSender::ProcessImuMsg_slot()
{
    if(!imu_serial-&gt;canReadLine())   return ;
    QByteArray readData = imu_serial-&gt;readAll();
    if(readData.isEmpty())  return ;

    if(readData[0] == '$')
    {
        QString ImuData_str = QString(readData);
        QStringList tmpImuData_Lis = ImuData_str.split(&quot;,&quot;);

        if (tmpImuData_Lis.count() == 24)
        {
            QString imuYawangle_str = tmpImuData_Lis[3];
            QString imuLatitude_str = tmpImuData_Lis[12];
            QString imuLongitude_str = tmpImuData_Lis[13];

            Position tmp_position(0, 0, 0);
            tmp_position.x = imuLongitude_str.toDouble();
            tmp_position.y = imuLatitude_str.toDouble();
            tmp_position.theta = imuYawangle_str.toDouble();

            WGS2CART(car_position_,tmp_position);
            car_position_.x -= Origin_position_.x;
            car_position_.y -= Origin_position_.y;

            qDebug() &lt;&lt; &quot;x: &quot; &lt;&lt; car_position_.x &lt;&lt; &quot; y: &quot; &lt;&lt; car_position_.y &lt;&lt; &quot; z: &quot; &lt;&lt; car_position_.theta;

            chasis_state_.imu_state_ = 1;
            emit Chasis_state_signal(chasis_state_); 
            emit Car_position_signal(car_position_);  
       }
    }
    imu_serial-&gt;clear();
}

â€¢Slot:ReceiveCmdMsg_slot(control_msg) æ¥æ”¶LtkjCenteræ§åˆ¶æŒ‡ä»¤
void ChasisSender::ReceiveCmdMsg_slot(control_msg msg)  
{
    if(!msg.cmd_stop)
    {
        if(cmd_serial-&gt;isOpen())
        {
            cmd_angle = msg.cmd_angle;
            cmd_speed = msg.cmd_speed;
            SendCmdSerialData();
        }
        else
        {
            OpenCmdSerialport();
        }
    }
    else
    {
        if(cmd_serial-&gt;isOpen())
        {
            CloseCmdSerialport();
        }
    }
}
</code></pre>
<p><strong>UdpReceiver</strong><br>
UdpReceiveræ„é€ å³å¯åŠ¨udpæ¥æ”¶ï¼Œå…·ä½“ç»‘å®šçš„IPå’Œç«¯å£éœ€è¦åœ¨æ„é€ å‡½æ•°ä¸­ä¿®æ”¹ï¼Œè¿™é‡Œä¸å†æä¾›ä¿®æ”¹çš„æ¥å£ã€‚æ¥æ”¶çš„æ§½å‡½æ•°å·²ç»å†™å¥½ï¼Œè§£æéœ€è¦æ ¹æ®åè®®æ¥å®šï¼Œè¿™ä¸ªç•™ç€åæœŸå†åŠ ã€‚æµ‹è¯•é˜¶æ®µåªä¿è¯å®ç°åŠŸèƒ½ã€‚åœ¨udpæ¥æ”¶æ§½æ¥æ”¶åˆ°æ¶ˆæ¯ä¹‹åï¼Œè¿›è¡Œè§£æï¼Œå‘é€ä»»åŠ¡æŒ‡ä»¤åˆ°LtkjCenterã€‚</p>
<ul>
<li>Signal:CommandSingal(task_msg) å‘LtkjCenterå‘é€ä»»åŠ¡å‘½ä»¤</li>
<li>Slot:Udp_receiver_slot() æ¥æ”¶udpæ¶ˆæ¯å¹¶è¿›è¡Œè§£æ</li>
<li>Slot:Udp_position_slot(Position); æ¥æ”¶LtkjCenterè½¦è¾†ä½ç½®ä¿¡æ¯</li>
<li>Slot:Send_Timer_slot() å‘LtkjCenterå‘é€å¿ƒè·³</li>
</ul>
<pre><code>void UdpReceiver::Udp_receiver_slot() 
{
    while (udp_receiver_-&gt;hasPendingDatagrams()) 
    {
        QByteArray datagram;
        datagram.resize(udp_receiver_-&gt;pendingDatagramSize( ));
        udp_receiver_-&gt;readDatagram (datagram.data( ), datagram.size());

        if(datagram[0] == '$')
        {
            QString udp_str = QString(datagram);
            QStringList udp_str_list = udp_str.split(&quot;,&quot;);
            if(udp_str_list.count() == 4)
            {
                action = udp_str_list[1].toInt();
                end_pos_.setX(udp_str_list[2].toDouble());
                end_pos_.setY(udp_str_list[3].toDouble());
            }
        }
        // qDebug() &lt;&lt; datagram;
        task_msg_.state = action;
        task_msg_.point_target = end_pos_;
        emit CommandSingal(task_msg_);
    }
}
</code></pre>
<p><strong>LtkjCenter</strong><br>
LtkjCenteråŒ…å«äº†LtkjMapå’ŒLtkjControlä¸¤ä¸ªç±»ã€‚<br>
é€»è¾‘è§æµç¨‹å›¾</p>
<ul>
<li>Signal:Chasis_cmd_signal(control_msg) å‘ChasisSenderå‘é€æ§åˆ¶æŒ‡ä»¤ï¼Œè½¬è§’å’Œé€Ÿåº¦ä»¥åŠåœæ­¢ä¿¡å·</li>
<li>Slot:Command_slot(QString cmd) æ¥æ”¶UdpReceiverä»»åŠ¡æ¶ˆæ¯</li>
</ul>
<pre><code>void LtkjCenter::Command_slot(task_msg cmd)
{
    qDebug() &lt;&lt; &quot;rece from udp: &quot; &lt;&lt; cmd.state &lt;&lt; &quot; and &quot; &lt;&lt; cmd.point_target;
    if(cmd.state == 0)
    {
        if(track_timer-&gt;isActive())
        {
            track_timer-&gt;stop();
        }
        SetReady();
    }
    else if(cmd.state == 1)
    {
        end_position_.x = cmd.point_target.x();
        end_position_.y = cmd.point_target.y();
        end_position_.theta = 0;

        if(map_path_state_.map_state_ == 1 &amp;&amp; chasis_state_.imu_state_ == 1)
        {
            Position2QPointF(car_point, car_position_);
            Position2QPointF(end_point, end_position_);
            map_.AStar(car_point, end_point);           
            UpdateMapState();
        }
        else
        {
            qDebug() &lt;&lt; &quot;Error: map_state = 0 !&quot;;
            SetReady();
            return ;
        }

        if(map_path_state_.path_state_ == 1)
        {
            if(!track_timer-&gt;isActive())
            {
                track_timer-&gt;start(100);
            }
            else
            {
                SetReady();
                track_timer-&gt;start(100);
                qDebug() &lt;&lt; &quot;Warning: New Task Failed, Track task is in Progress&quot;;
            }

        }
        else
        {
            qDebug() &lt;&lt; &quot;Error: map_path = 0!&quot;;
            return ;
        }
    }
}
</code></pre>
<ul>
<li>Slot:Chasis_state_slot(ChasisState) æ¥æ”¶ChasisSenderåº•ç›˜çŠ¶æ€æ¶ˆæ¯<pre><code></code></pre>
</li>
</ul>
<p>void LtkjCenter::Chasis_state_slot(ChasisState state)<br>
{<br>
chasis_state_.imu_state_ = state.imu_state_;<br>
}```</p>
<ul>
<li>Slot:Chasis_position_slot(Position) æ¥æ”¶ChasisSenderè½¦è¾†ä½ç½®æ¶ˆæ¯</li>
</ul>
<pre><code class="language-void">{
    car_position_.x = pos.x;
    car_position_.y = pos.y;
    car_position_.theta = pos.theta;

    emit Position_signal(car_position_);
}```
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Practice | Missing number]]></title>
        <id>https://wangfengyi0228.github.io/post/practice-or-missing-number/</id>
        <link href="https://wangfengyi0228.github.io/post/practice-or-missing-number/">
        </link>
        <updated>2021-04-26T04:40:22.000Z</updated>
        <content type="html"><![CDATA[<p>Given a positive integer n(nâ‰¤40), pick n-1 numbers randomly from 1 to n and concatenate them in random order as a string s, which means there is a missing number between 1 and n. Can you find the missing number?(Notice that in some cases the answer will not be unique, and in these cases you only need to find one valid answer.ï¼‰</p>
<h2 id="sample-input-1">Sample Input 1:</h2>
<p>20<br>
81971112205101569183132414117</p>
<h2 id="sample-output-1">Sample Output 1:</h2>
<p>16</p>
<h1 id="solution">Solution:</h1>
<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int len,n;
bool f[100];
string s;
int num[100];

void dfs(int k)
{
    if(k&gt;=len)
    {
        for(int i=1;i&lt;=n;i++)
        {
            if(f[i]==false)
            {
                printf(&quot;%d\n&quot;,i);
            }
        }
        return;
    }
    if(f[num[k]]==false)
    {
        f[num[k]]=true;
        dfs(k+1);
        f[num[k]]=false;
    }
    if(f[num[k]*10+num[k+1]]==false&amp;&amp;num[k]*10+num[k+1]&lt;=n)
    {
        f[num[k]*10+num[k+1]]=true;
        dfs(k+2);
        f[num[k]*10+num[k+1]]=false;
    }
}

int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    cin&gt;&gt;s;
    for(int i=0;i&lt;s.size();i++)
    {
        num[i]=s[i]-'0';
    }
    len=s.size();
    dfs(0);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Practice | Count number of binary strings without consecutive 1â€™s]]></title>
        <id>https://wangfengyi0228.github.io/post/practice-or-count-number-of-binary-strings-without-consecutive-1s/</id>
        <link href="https://wangfengyi0228.github.io/post/practice-or-count-number-of-binary-strings-without-consecutive-1s/">
        </link>
        <updated>2021-03-16T04:43:16.000Z</updated>
        <content type="html"><![CDATA[<p>Given a positive integer n(3â‰¤nâ‰¤90), count all possible distinct binary strings of length n such that there are no consecutive 1's .</p>
<h2 id="sample-input-1">Sample Input 1:</h2>
<p>2</p>
<h2 id="sample-output-1">Sample Output 1:</h2>
<p>3 // The 3 strings are 00, 01, 10</p>
<h2 id="sample-input-2">Sample Input 2:</h2>
<p>3</p>
<h2 id="sample-output-2">Sample Output 2:</h2>
<p>5 // The 5 strings are 000, 001, 010, 100, 101</p>
<h1 id="solution">Solution:</h1>
<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int pao(int n)
{
    if(n==1)
    {
        return 2;
    }
    else if(n==2)
    {
        return 3;
    }
    else
    {
        return pao(n-1)+pao(n-2);
    }
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int dp[100][2];
    dp[1][0]=1;
    dp[1][1]=1;
    for(int i=2;i&lt;=n;i++)
    {
        dp[i][0]=dp[i-1][0]+dp[i-1][1];
        dp[i][1]=dp[i-1][0];
    }
    printf(&quot;%d\n&quot;,dp[n][0]+dp[n][1]);
    printf(&quot;%d\n&quot;,pao(n));
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OD | æœ¯è¯­åè¯]]></title>
        <id>https://wangfengyi0228.github.io/post/od-or-zhu-yu-ming-ci/</id>
        <link href="https://wangfengyi0228.github.io/post/od-or-zhu-yu-ming-ci/">
        </link>
        <updated>2020-11-30T04:45:25.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1.å­¦ä¹ ç‡</strong><br>
å­¦ä¹ ç‡æ˜¯åœ¨æ¢¯åº¦ä¸‹é™çš„è¿‡ç¨‹ä¸­æ›´æ–°æƒé‡æ—¶çš„è¶…å‚æ•°ï¼Œå½“å­¦ä¹ ç‡è¿‡å¤§çš„æ—¶å€™ä¼šå¯¼è‡´æ¨¡å‹éš¾ä»¥æ”¶æ•›ï¼Œè¿‡å°çš„æ—¶å€™ä¼šæ”¶æ•›é€Ÿåº¦è¿‡æ…¢ï¼Œå­¦ä¹ ç‡æ˜¯ä¸€ä¸ªååˆ†é‡è¦çš„è¶…å‚æ•°ï¼Œåˆç†çš„å­¦ä¹ ç‡æ‰èƒ½è®©æ¨¡å‹æ”¶æ•›åˆ°æœ€å°ç‚¹è€Œéå±€éƒ¨æœ€ä¼˜ç‚¹æˆ–éç‚¹ã€‚</p>
<p><strong>2.æŸå¤±å‡½æ•°</strong><br>
æŸå¤±å‡½æ•°æ˜¯å°†éšæœºäº‹ä»¶æˆ–å…¶æœ‰å…³éšæœºå˜é‡çš„å–å€¼æ˜ å°„ä¸ºéè´Ÿå®æ•°ï¼Œä»¥è¡¨ç¤ºè¯¥éšæœºäº‹ä»¶çš„â€œé£é™©â€æˆ–â€œæŸå¤±â€çš„å‡½æ•°ã€‚</p>
<p><strong>3.å¬å›ç‡</strong><br>
å¬å›ç‡æ˜¯é’ˆå¯¹åŸæ¥çš„æ ·æœ¬è€Œè¨€çš„ï¼Œå®ƒè¡¨ç¤ºçš„æ˜¯æ ·æœ¬ä¸­çš„æ­£ä¾‹æœ‰å¤šå°‘è¢«é¢„æµ‹æ­£ç¡®äº†ã€‚é¢„æµ‹æœ‰ä¸¤ç§å¯èƒ½ï¼Œä¸€ç§æ˜¯æŠŠåŸæ¥çš„æ­£ç±»é¢„æµ‹æˆæ­£ç±»(TP)ï¼Œå¦ä¸€ç§å°±æ˜¯æŠŠåŸæ¥çš„æ­£ç±»é¢„æµ‹ä¸ºè´Ÿç±»(FN)ã€‚åˆ™</p>
<p><strong>4.äº¤å¹¶æ¯”ï¼ˆIOUï¼‰</strong><br>
äº¤å¹¶æ¯”æ—¶åœ¨ç›®æ ‡æ£€æµ‹ä»»åŠ¡ä¸­ï¼Œè®¡ç®—ä¸¤ä¸ªè¾¹ç•Œæ¡†ï¼ˆå®šä½çš„è¾¹ç•Œæ¡†å’Œå®é™…è¾¹ç•Œæ¡†ï¼‰çš„äº¤é›†å’Œå¹¶é›†ä¹‹æ¯”ã€‚ä¸€èˆ¬çº¦å®š,0.5 æ˜¯é˜ˆå€¼ï¼Œç”¨æ¥åˆ¤æ–­é¢„æµ‹çš„è¾¹ç•Œæ¡†æ˜¯å¦æ­£ç¡®ï¼ŒIOUè¶Šé«˜ï¼Œè¾¹ç•Œæ¡†è¶Šç²¾ç¡®ã€‚</p>
<p><strong>5.éæå¤§å€¼æŠ‘åˆ¶</strong><br>
ç®—æ³•å¯èƒ½å¯¹åŒä¸€ä¸ªå¯¹è±¡åšå‡ºå¤šæ¬¡æ£€æµ‹ï¼Œéæå¤§å€¼æŠ‘åˆ¶è¿™ä¸ªæ–¹æ³•å¯ä»¥ç¡®ä¿ç®—æ³•å¯¹æ¯ä¸ªå¯¹è±¡åªæ£€æµ‹ä¸€æ¬¡ã€‚é¦–å…ˆçœ‹æ£€æµ‹æ¦‚ç‡æœ€å¤§çš„è¾¹ç•Œæ¡†ï¼Œè¿›è¡Œæ ‡è®°ï¼Œä¹‹åéæå¤§å€¼æŠ‘åˆ¶å°±ä¼šé€ä¸€å®¡è§†å‰©ä¸‹çš„çŸ©å½¢ï¼Œæ‰€æœ‰å’Œè¿™ä¸ªæœ€å¤§çš„è¾¹æ¡†æœ‰å¾ˆé«˜äº¤å¹¶æ¯”ã€é«˜åº¦é‡å çš„å…¶ä»–è¾¹ç•Œæ¡†ï¼Œè¾“å‡ºå°±ä¼šè¢«æŠ‘åˆ¶ã€‚</p>
<p><strong>6.mAP(mean Average Precision)</strong><br>
æŸ¥å‡†ç‡ï¼ˆPrecisionï¼‰: TP/(TP + FP);æŸ¥å…¨ç‡ï¼ˆå³å„ç±»åˆ« AP çš„å¹³å‡å€¼Recallï¼‰: TP/(TP + FN)ã€‚äºŒè€…ç»˜åˆ¶çš„æ›²çº¿ç§°ä¸º P-R æ›²çº¿ã€‚APæ˜¯PR æ›²çº¿ä¸‹é¢ç§¯ã€‚mAPå³å„ç±»APçš„å¹³å‡å€¼ï¼Œç”¨æ¥è¡¡é‡ç›®æ ‡æ£€æµ‹ä¸­çš„è¯†åˆ«ç²¾åº¦ã€‚</p>
<p><strong>7.æ„Ÿå—é‡ï¼ˆReceptive Fieldï¼‰</strong><br>
åœ¨å·ç§¯ç¥ç»ç½‘ç»œä¸­ï¼Œæ„Ÿå—é‡ï¼ˆReceptive Fieldï¼‰çš„å®šä¹‰æ˜¯å·ç§¯ç¥ç»ç½‘ç»œæ¯ä¸€å±‚è¾“å‡ºçš„ç‰¹å¾å›¾ï¼ˆfeature mapï¼‰ä¸Šçš„åƒç´ ç‚¹åœ¨è¾“å…¥å›¾ç‰‡ä¸Šæ˜ å°„çš„åŒºåŸŸå¤§å°ï¼Œå³ç‰¹å¾å›¾ä¸Šçš„ä¸€ä¸ªç‚¹å¯¹åº”è¾“å…¥å›¾ä¸Šçš„åŒºåŸŸã€‚</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Practice | Root of AVL Tree]]></title>
        <id>https://wangfengyi0228.github.io/post/practice-or-root-of-avl-tree/</id>
        <link href="https://wangfengyi0228.github.io/post/practice-or-root-of-avl-tree/">
        </link>
        <updated>2019-11-19T04:36:26.000Z</updated>
        <content type="html"><![CDATA[<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.<br>
<img src="https://wangfengyi0228.github.io/post-images/1636692006948.png" alt="" loading="lazy"><br>
Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<h1 id="input-specification">Input Specification:</h1>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (â‰¤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h1 id="output-specification">Output Specification:</h1>
<p>For each test case, print the root of the resulting AVL tree in one line.</p>
<h2 id="sample-input-1">Sample Input 1:</h2>
<p>5<br>
88 70 61 96 120</p>
<h2 id="sample-output-1">Sample Output 1:</h2>
<p>70</p>
<h2 id="sample-input-2">Sample Input 2:</h2>
<p>7<br>
88 70 61 96 120 90 65</p>
<h2 id="sample-output-2">Sample Output 2:</h2>
<p>88</p>
<h1 id="solution">Solution:</h1>
<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef struct node
{
    int data,height;
    node *lchild,*rchild;
}node;

int getheight(node* k)
{
    if(k==nullptr)
        return 0;
    else return k-&gt;height;
}

node* l_rotate(node* &amp;k1)
{
    node *k2=k1-&gt;rchild;

    k1-&gt;rchild=k2-&gt;lchild;
    k2-&gt;lchild=k1;
    k1-&gt;height=max(getheight(k1-&gt;lchild),getheight(k1-&gt;rchild))+1;
    k2-&gt;height=max(getheight(k2-&gt;lchild),getheight(k2-&gt;rchild))+1;
    return k2;
}

node* r_rotate(node* &amp;k1)
{
    node *k2=k1-&gt;lchild;

    k1-&gt;lchild=k2-&gt;rchild;
    k2-&gt;rchild=k1;
    k1-&gt;height=max(getheight(k1-&gt;rchild),getheight(k1-&gt;lchild))+1;
    k2-&gt;height=max(getheight(k2-&gt;rchild),getheight(k2-&gt;lchild))+1;
    return k2;
}

node* lr_rotate(node* &amp;k1)
{
    k1-&gt;lchild=l_rotate(k1-&gt;lchild);
    return r_rotate(k1);
}

node* rl_rotate(node* &amp;k1)
{
    k1-&gt;rchild=r_rotate(k1-&gt;rchild);
    return l_rotate(k1);
}

node* insertnode(int d,node* &amp;root)
{
    if(root==nullptr)
    {
        root=(node*)malloc(sizeof(node));
        root-&gt;data=d;
        root-&gt;lchild=nullptr;
        root-&gt;rchild=nullptr;
        root-&gt;height=0;
    }
    else if(d&lt;root-&gt;data)
    {
        root-&gt;lchild=insertnode(d,root-&gt;lchild);
        if(getheight(root-&gt;lchild)-getheight(root-&gt;rchild)==2)
        {
            if(d&lt;root-&gt;lchild-&gt;data)
            {
                root=r_rotate(root);
            }
            else
            {
                root=lr_rotate(root);
            }
        }
    }
    else if(d&gt;root-&gt;data)
    {
        root-&gt;rchild=insertnode(d,root-&gt;rchild);
        if(getheight(root-&gt;rchild)-getheight(root-&gt;lchild)==2)
        {
            if(d&gt;root-&gt;rchild-&gt;data)
            {
                root=l_rotate(root);
            }
            else
            {
                root=rl_rotate(root);
            }
        }
    }
    root-&gt;height=max(getheight(root-&gt;lchild),getheight(root-&gt;rchild))+1;
    return root;
}

int main()
{
    int n;
    cin&gt;&gt;n;
    node *root=nullptr;
    for(int i=0;i&lt;n;i++)
    {
        int tmp;
        scanf(&quot;%d&quot;,&amp;tmp);
        root=insertnode(tmp,root);
    }
    printf(&quot;%d&quot;,root-&gt;data);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome to My World]]></title>
        <id>https://wangfengyi0228.github.io/post/hello-gridea/</id>
        <link href="https://wangfengyi0228.github.io/post/hello-gridea/">
        </link>
        <updated>2000-02-28T14:45:00.000Z</updated>
        <content type="html"><![CDATA[<p>2000-02-28  Student ï¼Œ  XMU</p>
<p>ğŸ‘ æ¬¢è¿æ¥åˆ°æˆ‘çš„blog ï¼æŒç»­å»ºè®¾ing<br>
âœï¸ è®°å½•æˆ‘çš„ç¬”è®°ã€ç”Ÿæ´»ã€å¿ƒæƒ…... ...<br>
ğŸ¤™ ä¸è¦é—®æˆ‘ä¸ºä»€ä¹ˆå›¾æ–‡ä¸ç¬¦ï¼Œå› ä¸ºæˆ‘æ„¿æ„ğŸ˜‹</p>
<p>ğŸ“ æƒ³è¦äº†è§£æ›´å¤šæˆ–è”ç³»åšä¸»è¯·æŸ¥çœ‹å…³äº<br>
ğŸ•™ æƒ³è¦æŒ‰æ—¶é—´æ£€ç´¢æ–‡ç« è¯·æŸ¥çœ‹å½’æ¡£<br>
ğŸ“‘ æƒ³è¦æŒ‰tagæ£€ç´¢æ–‡ç« è¯·æŸ¥çœ‹æ ‡ç­¾<br>
ğŸ”å³ä¸Šè§’æœ‰å¯¼èˆªæ å“¦</p>
<p>ğŸŒ± å½“ç„¶ wfy è¿˜æœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡æˆ‘ä¼šä¸åœå‘å‰ ğŸƒ</p>
<p>ğŸ˜ Enjoy~</p>
<p>2021.9.19 | æ›´æ–°äº†æ ‡ç­¾æ£€ç´¢åŠŸèƒ½<br>
2021.9.21 | å°è¯•æ·»åŠ è¯„è®ºåŠŸèƒ½å¤±è´¥ï¼Œå› ä¸ºdisqusè¢«å¢™äº†ğŸ˜­ï¼Œå°ç‹è¿˜åœ¨åŠªåŠ›ä¸­<br>
2021.9.27 | æ–°å¢ç½‘ç«™è®¿å®¢ç»Ÿè®¡åŠè®¿é—®é‡ç»Ÿè®¡åŠŸèƒ½<br>
2021.9.28 | æ–°å¢æ–‡ç« é˜…è¯»é‡ç»Ÿè®¡åŠŸèƒ½<br>
2021.10.2 | æ–°å¢Katexæ¸²æŸ“ï¼Œå¯ä»¥ç”¨markdownå†™å…¬å¼å•¦</p>
]]></content>
    </entry>
</feed>