<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangfengyi0228.github.io</id>
    <title>one in a million</title>
    <updated>2021-11-12T04:42:46.735Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangfengyi0228.github.io"/>
    <link rel="self" href="https://wangfengyi0228.github.io/atom.xml"/>
    <subtitle>æˆ‘åœ¨ä½ çš„å¿ƒé‡Œï¼Œæœ‰æ²¡æœ‰ä¸€ç‚¹ç‰¹åˆ«</subtitle>
    <logo>https://wangfengyi0228.github.io/images/avatar.png</logo>
    <icon>https://wangfengyi0228.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, one in a million</rights>
    <entry>
        <title type="html"><![CDATA[Qt | æ™ºèƒ½å·¡æ£€æœºå™¨äººé¡¹ç›®]]></title>
        <id>https://wangfengyi0228.github.io/post/qt-or-zhi-neng-xun-jian-ji-qi-ren-xiang-mu/</id>
        <link href="https://wangfengyi0228.github.io/post/qt-or-zhi-neng-xun-jian-ji-qi-ren-xiang-mu/">
        </link>
        <updated>2021-08-28T03:38:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>notes:è¯¥æœºå™¨äººä½¿ç”¨å«æ˜Ÿè¿›è¡Œç»çº¬åº¦å®šä½ï¼Œé€‚ç”¨äºå¼€é˜”åœ°å¸¦ï¼Œåˆå§‹åŒ–æœæ˜Ÿæ•°è¾¾åˆ°19ä»¥ä¸Šä¸ºä½³ï¼Œè·ç¦»ç²¾åº¦ç²¾ç¡®åˆ°å°æ•°ç‚¹å16ä½ï¼ˆä»¥ç±³ä¸ºå•ä½ï¼‰<br>
<strong>é¡¹ç›®æ€»ä½“æ¡†å›¾ï¼š</strong><br>
<img src="https://wangfengyi0228.github.io/post-images/1636688828688.png" alt="" loading="lazy"><br>
<strong>é€»è¾‘æµç¨‹å›¾ï¼š</strong><br>
<img src="https://wangfengyi0228.github.io/post-images/1636691559203.png" alt="" loading="lazy"><br>
<strong>ChasisSender</strong><br>
ChasisSenderæ„é€ å³å¯åŠ¨ä¸¤ä¸ªä¸²å£ï¼ˆImuä¸²å£å’ŒCmdä¸²å£ï¼‰ï¼ŒImuä¸²å£è´Ÿè´£æ¥æ”¶Imuæ•°æ®å’Œå®šä½æ•°æ®ï¼Œå°†æ•°æ®è§£æåå‘é€åˆ°LtkjCenterã€‚Cmdä¸²å£è´Ÿè´£å‘é€æ§åˆ¶æŒ‡ä»¤ï¼ˆé€Ÿåº¦å’Œè½¬è§’ï¼‰åˆ°åº•ç›˜æ§åˆ¶å™¨ï¼Œè‡ªå®šä¹‰æ ¼å¼ä¸ºâ€œ$cmd,è½¬è§’,é€Ÿåº¦\r\nâ€ã€‚Cmdä¸²å£æ•°æ®çš„å‘é€åœ¨æ¥æ”¶åˆ°LtkjCenterçš„control_msgä¿¡å·åï¼Œå¼€å§‹å‘é€ï¼Œæ¥æ”¶åˆ°control_msg.cmd_stopä¿¡å·åå…³é—­cmdä¸²å£ï¼Œåœæ­¢å‘é€ã€‚</p>
</blockquote>
<ul>
<li>Signal:Chasis_state_signal(ChasisState) å‘LtkjCenterå‘é€åº•ç›˜çŠ¶æ€</li>
<li>Signal:Car_position_signal(Position) å‘LtkjCenterå‘é€è½¦è¾†ä½ç½®</li>
<li>Slot:ProcessImuMsg_slot() æ¥æ”¶Imuä¸²å£æ¶ˆæ¯</li>
</ul>
<pre><code>void ChasisSender::ProcessImuMsg_slot()
{
    if(!imu_serial-&gt;canReadLine())   return ;
    QByteArray readData = imu_serial-&gt;readAll();
    if(readData.isEmpty())  return ;

    if(readData[0] == '$')
    {
        QString ImuData_str = QString(readData);
        QStringList tmpImuData_Lis = ImuData_str.split(&quot;,&quot;);

        if (tmpImuData_Lis.count() == 24)
        {
            QString imuYawangle_str = tmpImuData_Lis[3];
            QString imuLatitude_str = tmpImuData_Lis[12];
            QString imuLongitude_str = tmpImuData_Lis[13];

            Position tmp_position(0, 0, 0);
            tmp_position.x = imuLongitude_str.toDouble();
            tmp_position.y = imuLatitude_str.toDouble();
            tmp_position.theta = imuYawangle_str.toDouble();

            WGS2CART(car_position_,tmp_position);
            car_position_.x -= Origin_position_.x;
            car_position_.y -= Origin_position_.y;

            qDebug() &lt;&lt; &quot;x: &quot; &lt;&lt; car_position_.x &lt;&lt; &quot; y: &quot; &lt;&lt; car_position_.y &lt;&lt; &quot; z: &quot; &lt;&lt; car_position_.theta;

            chasis_state_.imu_state_ = 1;
            emit Chasis_state_signal(chasis_state_); 
            emit Car_position_signal(car_position_);  
       }
    }
    imu_serial-&gt;clear();
}

â€¢Slot:ReceiveCmdMsg_slot(control_msg) æ¥æ”¶LtkjCenteræ§åˆ¶æŒ‡ä»¤
void ChasisSender::ReceiveCmdMsg_slot(control_msg msg)  
{
    if(!msg.cmd_stop)
    {
        if(cmd_serial-&gt;isOpen())
        {
            cmd_angle = msg.cmd_angle;
            cmd_speed = msg.cmd_speed;
            SendCmdSerialData();
        }
        else
        {
            OpenCmdSerialport();
        }
    }
    else
    {
        if(cmd_serial-&gt;isOpen())
        {
            CloseCmdSerialport();
        }
    }
}
</code></pre>
<p><strong>UdpReceiver</strong><br>
UdpReceiveræ„é€ å³å¯åŠ¨udpæ¥æ”¶ï¼Œå…·ä½“ç»‘å®šçš„IPå’Œç«¯å£éœ€è¦åœ¨æ„é€ å‡½æ•°ä¸­ä¿®æ”¹ï¼Œè¿™é‡Œä¸å†æä¾›ä¿®æ”¹çš„æ¥å£ã€‚æ¥æ”¶çš„æ§½å‡½æ•°å·²ç»å†™å¥½ï¼Œè§£æéœ€è¦æ ¹æ®åè®®æ¥å®šï¼Œè¿™ä¸ªç•™ç€åæœŸå†åŠ ã€‚æµ‹è¯•é˜¶æ®µåªä¿è¯å®ç°åŠŸèƒ½ã€‚åœ¨udpæ¥æ”¶æ§½æ¥æ”¶åˆ°æ¶ˆæ¯ä¹‹åï¼Œè¿›è¡Œè§£æï¼Œå‘é€ä»»åŠ¡æŒ‡ä»¤åˆ°LtkjCenterã€‚</p>
<ul>
<li>Signal:CommandSingal(task_msg) å‘LtkjCenterå‘é€ä»»åŠ¡å‘½ä»¤</li>
<li>Slot:Udp_receiver_slot() æ¥æ”¶udpæ¶ˆæ¯å¹¶è¿›è¡Œè§£æ</li>
<li>Slot:Udp_position_slot(Position); æ¥æ”¶LtkjCenterè½¦è¾†ä½ç½®ä¿¡æ¯</li>
<li>Slot:Send_Timer_slot() å‘LtkjCenterå‘é€å¿ƒè·³</li>
</ul>
<pre><code>void UdpReceiver::Udp_receiver_slot() 
{
    while (udp_receiver_-&gt;hasPendingDatagrams()) 
    {
        QByteArray datagram;
        datagram.resize(udp_receiver_-&gt;pendingDatagramSize( ));
        udp_receiver_-&gt;readDatagram (datagram.data( ), datagram.size());

        if(datagram[0] == '$')
        {
            QString udp_str = QString(datagram);
            QStringList udp_str_list = udp_str.split(&quot;,&quot;);
            if(udp_str_list.count() == 4)
            {
                action = udp_str_list[1].toInt();
                end_pos_.setX(udp_str_list[2].toDouble());
                end_pos_.setY(udp_str_list[3].toDouble());
            }
        }
        // qDebug() &lt;&lt; datagram;
        task_msg_.state = action;
        task_msg_.point_target = end_pos_;
        emit CommandSingal(task_msg_);
    }
}
</code></pre>
<p><strong>LtkjCenter</strong><br>
LtkjCenteråŒ…å«äº†LtkjMapå’ŒLtkjControlä¸¤ä¸ªç±»ã€‚<br>
é€»è¾‘è§æµç¨‹å›¾</p>
<ul>
<li>Signal:Chasis_cmd_signal(control_msg) å‘ChasisSenderå‘é€æ§åˆ¶æŒ‡ä»¤ï¼Œè½¬è§’å’Œé€Ÿåº¦ä»¥åŠåœæ­¢ä¿¡å·</li>
<li>Slot:Command_slot(QString cmd) æ¥æ”¶UdpReceiverä»»åŠ¡æ¶ˆæ¯</li>
</ul>
<pre><code>void LtkjCenter::Command_slot(task_msg cmd)
{
    qDebug() &lt;&lt; &quot;rece from udp: &quot; &lt;&lt; cmd.state &lt;&lt; &quot; and &quot; &lt;&lt; cmd.point_target;
    if(cmd.state == 0)
    {
        if(track_timer-&gt;isActive())
        {
            track_timer-&gt;stop();
        }
        SetReady();
    }
    else if(cmd.state == 1)
    {
        end_position_.x = cmd.point_target.x();
        end_position_.y = cmd.point_target.y();
        end_position_.theta = 0;

        if(map_path_state_.map_state_ == 1 &amp;&amp; chasis_state_.imu_state_ == 1)
        {
            Position2QPointF(car_point, car_position_);
            Position2QPointF(end_point, end_position_);
            map_.AStar(car_point, end_point);           
            UpdateMapState();
        }
        else
        {
            qDebug() &lt;&lt; &quot;Error: map_state = 0 !&quot;;
            SetReady();
            return ;
        }

        if(map_path_state_.path_state_ == 1)
        {
            if(!track_timer-&gt;isActive())
            {
                track_timer-&gt;start(100);
            }
            else
            {
                SetReady();
                track_timer-&gt;start(100);
                qDebug() &lt;&lt; &quot;Warning: New Task Failed, Track task is in Progress&quot;;
            }

        }
        else
        {
            qDebug() &lt;&lt; &quot;Error: map_path = 0!&quot;;
            return ;
        }
    }
}
</code></pre>
<ul>
<li>Slot:Chasis_state_slot(ChasisState) æ¥æ”¶ChasisSenderåº•ç›˜çŠ¶æ€æ¶ˆæ¯<pre><code></code></pre>
</li>
</ul>
<p>void LtkjCenter::Chasis_state_slot(ChasisState state)<br>
{<br>
chasis_state_.imu_state_ = state.imu_state_;<br>
}```</p>
<ul>
<li>Slot:Chasis_position_slot(Position) æ¥æ”¶ChasisSenderè½¦è¾†ä½ç½®æ¶ˆæ¯</li>
</ul>
<pre><code class="language-void">{
    car_position_.x = pos.x;
    car_position_.y = pos.y;
    car_position_.theta = pos.theta;

    emit Position_signal(car_position_);
}```
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Practice | Missing number]]></title>
        <id>https://wangfengyi0228.github.io/post/practice-or-missing-number/</id>
        <link href="https://wangfengyi0228.github.io/post/practice-or-missing-number/">
        </link>
        <updated>2021-04-26T04:40:22.000Z</updated>
        <content type="html"><![CDATA[<p>Given a positive integer n(nâ‰¤40), pick n-1 numbers randomly from 1 to n and concatenate them in random order as a string s, which means there is a missing number between 1 and n. Can you find the missing number?(Notice that in some cases the answer will not be unique, and in these cases you only need to find one valid answer.ï¼‰</p>
<h2 id="sample-input-1">Sample Input 1:</h2>
<p>20<br>
81971112205101569183132414117</p>
<h2 id="sample-output-1">Sample Output 1:</h2>
<p>16</p>
<h1 id="solution">Solution:</h1>
<p>#include &lt;bits/stdc++.h&gt;</p>
<p>using namespace std;</p>
<p>int len,n;<br>
bool f[100];<br>
string s;<br>
int num[100];</p>
<p>void dfs(int k)<br>
{<br>
if(k&gt;=len)<br>
{<br>
for(int i=1;i&lt;=n;i++)<br>
{<br>
if(f[i]==false)<br>
{<br>
printf(&quot;%d\n&quot;,i);<br>
}<br>
}<br>
return;<br>
}<br>
if(f[num[k]]==false)<br>
{<br>
f[num[k]]=true;<br>
dfs(k+1);<br>
f[num[k]]=false;<br>
}<br>
if(f[num[k]*10+num[k+1]]==false&amp;&amp;num[k]*10+num[k+1]&lt;=n)<br>
{<br>
f[num[k]*10+num[k+1]]=true;<br>
dfs(k+2);<br>
f[num[k]*10+num[k+1]]=false;<br>
}<br>
}</p>
<p>int main()<br>
{<br>
scanf(&quot;%d&quot;,&amp;n);<br>
cin&gt;&gt;s;<br>
for(int i=0;i&lt;s.size();i++)<br>
{<br>
num[i]=s[i]-'0';<br>
}<br>
len=s.size();<br>
dfs(0);<br>
return 0;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Practice | Root of AVL Tree]]></title>
        <id>https://wangfengyi0228.github.io/post/practice-or-root-of-avl-tree/</id>
        <link href="https://wangfengyi0228.github.io/post/practice-or-root-of-avl-tree/">
        </link>
        <updated>2019-11-19T04:36:26.000Z</updated>
        <content type="html"><![CDATA[<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.<br>
<img src="https://wangfengyi0228.github.io/post-images/1636692006948.png" alt="" loading="lazy"><br>
Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<h1 id="input-specification">Input Specification:</h1>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (â‰¤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h1 id="output-specification">Output Specification:</h1>
<p>For each test case, print the root of the resulting AVL tree in one line.</p>
<h2 id="sample-input-1">Sample Input 1:</h2>
<p>5<br>
88 70 61 96 120</p>
<h2 id="sample-output-1">Sample Output 1:</h2>
<p>70</p>
<h2 id="sample-input-2">Sample Input 2:</h2>
<p>7<br>
88 70 61 96 120 90 65</p>
<h2 id="sample-output-2">Sample Output 2:</h2>
<p>88</p>
<h1 id="solution">Solution:</h1>
<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef struct node
{
    int data,height;
    node *lchild,*rchild;
}node;

int getheight(node* k)
{
    if(k==nullptr)
        return 0;
    else return k-&gt;height;
}

node* l_rotate(node* &amp;k1)
{
    node *k2=k1-&gt;rchild;

    k1-&gt;rchild=k2-&gt;lchild;
    k2-&gt;lchild=k1;
    k1-&gt;height=max(getheight(k1-&gt;lchild),getheight(k1-&gt;rchild))+1;
    k2-&gt;height=max(getheight(k2-&gt;lchild),getheight(k2-&gt;rchild))+1;
    return k2;
}

node* r_rotate(node* &amp;k1)
{
    node *k2=k1-&gt;lchild;

    k1-&gt;lchild=k2-&gt;rchild;
    k2-&gt;rchild=k1;
    k1-&gt;height=max(getheight(k1-&gt;rchild),getheight(k1-&gt;lchild))+1;
    k2-&gt;height=max(getheight(k2-&gt;rchild),getheight(k2-&gt;lchild))+1;
    return k2;
}

node* lr_rotate(node* &amp;k1)
{
    k1-&gt;lchild=l_rotate(k1-&gt;lchild);
    return r_rotate(k1);
}

node* rl_rotate(node* &amp;k1)
{
    k1-&gt;rchild=r_rotate(k1-&gt;rchild);
    return l_rotate(k1);
}

node* insertnode(int d,node* &amp;root)
{
    if(root==nullptr)
    {
        root=(node*)malloc(sizeof(node));
        root-&gt;data=d;
        root-&gt;lchild=nullptr;
        root-&gt;rchild=nullptr;
        root-&gt;height=0;
    }
    else if(d&lt;root-&gt;data)
    {
        root-&gt;lchild=insertnode(d,root-&gt;lchild);
        if(getheight(root-&gt;lchild)-getheight(root-&gt;rchild)==2)
        {
            if(d&lt;root-&gt;lchild-&gt;data)
            {
                root=r_rotate(root);
            }
            else
            {
                root=lr_rotate(root);
            }
        }
    }
    else if(d&gt;root-&gt;data)
    {
        root-&gt;rchild=insertnode(d,root-&gt;rchild);
        if(getheight(root-&gt;rchild)-getheight(root-&gt;lchild)==2)
        {
            if(d&gt;root-&gt;rchild-&gt;data)
            {
                root=l_rotate(root);
            }
            else
            {
                root=rl_rotate(root);
            }
        }
    }
    root-&gt;height=max(getheight(root-&gt;lchild),getheight(root-&gt;rchild))+1;
    return root;
}

int main()
{
    int n;
    cin&gt;&gt;n;
    node *root=nullptr;
    for(int i=0;i&lt;n;i++)
    {
        int tmp;
        scanf(&quot;%d&quot;,&amp;tmp);
        root=insertnode(tmp,root);
    }
    printf(&quot;%d&quot;,root-&gt;data);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome to My World]]></title>
        <id>https://wangfengyi0228.github.io/post/hello-gridea/</id>
        <link href="https://wangfengyi0228.github.io/post/hello-gridea/">
        </link>
        <updated>2000-02-28T14:45:00.000Z</updated>
        <content type="html"><![CDATA[<p>2000-02-28  Student ï¼Œ  XMU</p>
<p>ğŸ‘ æ¬¢è¿æ¥åˆ°æˆ‘çš„blog ï¼æŒç»­å»ºè®¾ing<br>
âœï¸ è®°å½•æˆ‘çš„ç¬”è®°ã€ç”Ÿæ´»ã€å¿ƒæƒ…... ...<br>
ğŸ¤™ ä¸è¦é—®æˆ‘ä¸ºä»€ä¹ˆå›¾æ–‡ä¸ç¬¦ï¼Œå› ä¸ºæˆ‘æ„¿æ„ğŸ˜‹</p>
<p>ğŸ“ æƒ³è¦äº†è§£æ›´å¤šæˆ–è”ç³»åšä¸»è¯·æŸ¥çœ‹å…³äº<br>
ğŸ•™ æƒ³è¦æŒ‰æ—¶é—´æ£€ç´¢æ–‡ç« è¯·æŸ¥çœ‹å½’æ¡£<br>
ğŸ“‘ æƒ³è¦æŒ‰tagæ£€ç´¢æ–‡ç« è¯·æŸ¥çœ‹æ ‡ç­¾<br>
ğŸ”å³ä¸Šè§’æœ‰å¯¼èˆªæ å“¦</p>
<p>ğŸŒ± å½“ç„¶ wfy è¿˜æœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡æˆ‘ä¼šä¸åœå‘å‰ ğŸƒ</p>
<p>ğŸ˜ Enjoy~</p>
<p>2021.9.19 | æ›´æ–°äº†æ ‡ç­¾æ£€ç´¢åŠŸèƒ½<br>
2021.9.21 | å°è¯•æ·»åŠ è¯„è®ºåŠŸèƒ½å¤±è´¥ï¼Œå› ä¸ºdisqusè¢«å¢™äº†ğŸ˜­ï¼Œå°ç‹è¿˜åœ¨åŠªåŠ›ä¸­<br>
2021.9.27 | æ–°å¢ç½‘ç«™è®¿å®¢ç»Ÿè®¡åŠè®¿é—®é‡ç»Ÿè®¡åŠŸèƒ½<br>
2021.9.28 | æ–°å¢æ–‡ç« é˜…è¯»é‡ç»Ÿè®¡åŠŸèƒ½<br>
2021.10.2 | æ–°å¢Katexæ¸²æŸ“ï¼Œå¯ä»¥ç”¨markdownå†™å…¬å¼å•¦</p>
]]></content>
    </entry>
</feed>